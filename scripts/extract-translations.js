#!/usr/bin/env node

/**
 * Translation Extraction Script
 * Scans all TSX files in src/pages and src/components
 * Extracts Turkish content for translation
 * Generates: src/data/static/translationSources.ts
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = path.join(__dirname, '../src');
const OUTPUT_FILE = path.join(__dirname, '../src/data/static/translationSources.ts');

// Turkish character detection regex
// Matches strings containing at least one Turkish-specific character OR common Turkish words
const TURKISH_CHARS = /[Ä±ÄŸÃ¼ÅŸÃ¶Ã§ÄžÃœÅžÄ°Ã–Ã‡]/;

// Directories to scan
const SCAN_DIRS = [
  path.join(SRC_DIR, 'pages'),
  path.join(SRC_DIR, 'components')
];

// Extract strings from file content
function extractStrings(content) {
  const strings = new Set();

  // Match string literals in various contexts
  const patterns = [
    // JSX text content: >text<
    />([^<>{}]+)</g,
    // String literals: "text" or 'text'
    /["']([^"']+)["']/g,
    // Template literals: `text`
    /`([^`]+)`/g,
    // placeholder attributes
    /placeholder=["']([^"']+)["']/g,
    // title attributes
    /title=["']([^"']+)["']/g,
    // alt attributes
    /alt=["']([^"']+)["']/g,
    // label attributes
    /label=["']([^"']+)["']/g
  ];

  patterns.forEach(pattern => {
    let match;
    // Reset lastIndex for global regexes if reused, but here we create new ones or use literals in loop
    // Since we use literals in the array, we need to be careful. 
    // Actually, let's just create a new RegExp from the source to be safe and clean.
    const regex = new RegExp(pattern.source, 'g');
    
    while ((match = regex.exec(content)) !== null) {
      let text = match[1].trim();
      
      // Clean up whitespace (replace newlines and multiple spaces with single space)
      text = text.replace(/\s+/g, ' ');

      // Filter criteria
      if (
        text.length > 2 && // Min length
        !text.match(/^[0-9]+$/) && // Not just numbers
        !text.includes('http') && // Not URLs
        !text.includes('import ') && // Not imports
        !text.includes('from ') && // Not imports
        !text.includes('const ') && // Not code
        !text.includes('return ') && // Not code
        !text.includes('className') && // Not code
        !text.includes('motion.') && // Not framer motion code
        !text.includes('initial={{') && // Not framer motion props
        !text.startsWith('/') && // Not paths
        !text.startsWith('{') && // Not objects
        !text.startsWith('>') && // Not closing tags artifacts
        (TURKISH_CHARS.test(text) || isLikelyTurkish(text)) // Must look Turkish
      ) {
        strings.add(text);
      }
    }
  });

  return Array.from(strings);
}

// Heuristic to detect Turkish text even without special chars (e.g. "Hemen Baslayin")
function isLikelyTurkish(text) {
  // Common Turkish words/suffixes (simplified)
  const common = ['ve', 'ile', 'iÃ§in', 'bir', 'bu', 'ÅŸu', 'o', 'ama', 'fakat', 'lakin', 'ancak', 'yap', 'et', 'ol', 'gel', 'git'];
  const words = text.toLowerCase().split(/\s+/);
  return words.some(w => common.includes(w)) && words.length > 1;
}

// Recursively scan directory
function scanDirectory(dir, results = {}) {
  if (!fs.existsSync(dir)) return results;

  const files = fs.readdirSync(dir);

  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      scanDirectory(filePath, results);
    } else if (file.endsWith('.tsx') || file.endsWith('.ts')) {
      // Skip definition files and tests
      if (file.endsWith('.d.ts') || file.endsWith('.test.tsx') || file.endsWith('.spec.tsx')) return;

      const content = fs.readFileSync(filePath, 'utf-8');
      const strings = extractStrings(content);
      
      if (strings.length > 0) {
        // Use filename as key (remove extension)
        const key = path.basename(file, path.extname(file));
        
        if (!results[key]) {
          results[key] = [];
        }
        results[key].push(...strings);
      }
    }
  });

  return results;
}

// Generate TS file content
function generateTSContent(groupedStrings) {
  let content = `// Auto-generated by scripts/extract-translations.js\n`;
  content += `// Run 'npm run scan-translations' to update this file\n\n`;
  content += `export const staticTranslationTexts: Record<string, string[]> = {\n`;

  // Sort keys for stability
  const sortedKeys = Object.keys(groupedStrings).sort();

  for (const key of sortedKeys) {
    const texts = groupedStrings[key];
    // Remove duplicates and sort
    const uniqueTexts = [...new Set(texts)].sort();
    
    if (uniqueTexts.length === 0) continue;

    content += `  "${key}": [\n`;
    uniqueTexts.forEach(text => {
      // Escape double quotes and backslashes
      const safeText = text.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
      content += `    "${safeText}",\n`;
    });
    content += `  ],\n`;
  }

  content += `};\n`;
  
  // Add helper function
  content += `\nexport type TranslationSourceKey = keyof typeof staticTranslationTexts;\n\n`;
  content += `export function getAllStaticTranslations() {\n`;
  content += `  const allTranslations: Array<{ context: string; text: string }> = [];\n\n`;
  content += `  for (const [context, texts] of Object.entries(staticTranslationTexts)) {\n`;
  content += `    for (const text of texts) {\n`;
  content += `      allTranslations.push({ context, text });\n`;
  content += `    }\n`;
  content += `  }\n\n`;
  content += `  return allTranslations;\n`;
  content += `}\n`;

  return content;
}

// Main execution
console.log('ðŸ” Scanning for Turkish content...');
const allResults = {};

SCAN_DIRS.forEach(dir => {
  scanDirectory(dir, allResults);
});

const totalFiles = Object.keys(allResults).length;
const totalStrings = Object.values(allResults).reduce((acc, arr) => acc + arr.length, 0);

console.log(`âœ… Found ${totalStrings} strings in ${totalFiles} files.`);

const fileContent = generateTSContent(allResults);
fs.writeFileSync(OUTPUT_FILE, fileContent);

console.log(`ðŸ’¾ Saved to ${path.relative(process.cwd(), OUTPUT_FILE)}`);
